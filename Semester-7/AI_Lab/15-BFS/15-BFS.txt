% --------------------------------------------
% গ্রাফের এজ বা সংযোগ সংজ্ঞায়িত করা হয়েছে (directed edges)
% --------------------------------------------
edge(a, b).  % a থেকে b তে সংযোগ আছে
edge(a, c).  % a থেকে c তে সংযোগ আছে
edge(b, d).  % b থেকে d তে সংযোগ আছে
edge(b, e).  % b থেকে e তে সংযোগ আছে
edge(c, f).  % c থেকে f তে সংযোগ আছে
edge(e, f).  % e থেকে f তে সংযোগ আছে

% --------------------------------------------
% BFS ট্রাভার্সাল শুরু করার প্রধান predicate
% Start থেকে Goal পর্যন্ত path বের করে Path-এ
% --------------------------------------------
bfs(Start, Goal, Path) :- 
    bfs_helper([[Start]], Goal, Path).  % প্রাথমিকভাবে queue-তে শুধু Start node রয়েছে

% --------------------------------------------
% যখন Goal পাওয়া যায়: path টা রিভার্স করে রিটার্ন করা হয়
% --------------------------------------------
bfs_helper([[Goal | Rest] | _], Goal, Path) :- 
    reverse([Goal | Rest], Path).  % Goal সহ পুরো path টা রিভার্স করে ফিরিয়ে দাও

% --------------------------------------------
% মূল BFS হেল্পার লজিক
% --------------------------------------------
bfs_helper([[Current | Rest] | Queue], Goal, Path) :-
    % বর্তমান নোডের সাথে সংযুক্ত নতুন নোডগুলোর path বের করা হচ্ছে
    findall(
        [Next, Current | Rest],                          % নতুন path তৈরি (Next <- Current <- ...)
        (edge(Current, Next), \+ member(Next, [Current | Rest])),  % যদি সংযোগ থাকে এবং আগেই ভিজিট না করা হয়ে থাকে
        NewPaths
    ),
    append(Queue, NewPaths, NewQueue),  % নতুন path গুলো queue-তে যোগ করো (FIFO)
    bfs_helper(NewQueue, Goal, Path).   % রিকার্সিভলি BFS চালিয়ে যাও

% --------------------------------------------
% উদাহরণ কুয়েরি:
% ?- bfs(a, f, Path).
% মানে: a থেকে f পর্যন্ত BFS ভিত্তিক সবচেয়ে কম ধাপে যাওয়া সম্ভব এমন path খুঁজে বের করো

output: Path = [a, c, f].
% --------------------------------------------

